<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>RFH | AI Coach</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM" crossorigin="anonymous">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Montserrat:wght@700;900&family=Roboto:wght@300;400;500&display=swap"
        rel="stylesheet">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="css/styles.css">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <style>
        body,
        html {
            height: 100%;
        }

        .chat-container {
            height: calc(100vh - 76px);
            /* Adjust for navbar */
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .chat-history {
            flex-grow: 1;
            overflow-y: auto;
            padding: 2rem;
            padding-bottom: 6rem;
            /* Extra padding at bottom for input area */
        }

        .chat-input-area {
            padding: 1.5rem 2rem;
            background-color: #0a0a0a;
            border-top: 2px solid #333;
            position: sticky;
            bottom: 0;
            z-index: 10;
            box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
        }

        .scroll-hint {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(208, 0, 0, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.85rem;
            animation: bounceHint 2s ease-in-out infinite;
            pointer-events: none;
            z-index: 5;
            white-space: nowrap;
        }

        .scroll-hint::after {
            content: 'â†“';
            display: inline-block;
            margin-left: 0.5rem;
            animation: bounceArrow 1s ease-in-out infinite;
        }

        @keyframes bounceHint {

            0%,
            100% {
                transform: translateX(-50%) translateY(0);
                opacity: 0.8;
            }

            50% {
                transform: translateX(-50%) translateY(-10px);
                opacity: 1;
            }
        }

        @keyframes bounceArrow {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(5px);
            }
        }

        .scroll-hint.hidden {
            display: none;
        }

        .message {
            max-width: 80%;
            margin-bottom: 1.5rem;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            line-height: 1.5;
            animation: messageSlideIn 0.3s ease-out;
        }

        .message.user {
            background-color: #333;
            color: #fff;
            margin-left: auto;
            border-bottom-right-radius: 0;
        }

        .message.ai {
            background-color: #d00000;
            color: #fff;
            margin-right: auto;
            border-bottom-left-radius: 0;
        }

        .typing-indicator {
            display: none;
            color: #888;
            font-size: 0.9rem;
            margin-bottom: 1rem;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 9999;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s ease-in-out;
        }

        .loading-card {
            background: linear-gradient(135deg, #1a1a1a 0%, #2d0000 100%);
            border: 2px solid #d00000;
            border-radius: 16px;
            padding: 2.5rem 3rem;
            text-align: center;
            box-shadow: 0 10px 50px rgba(208, 0, 0, 0.3),
                0 0 30px rgba(208, 0, 0, 0.2);
            animation: scaleIn 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            min-width: 280px;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(208, 0, 0, 0.2);
            border-top: 4px solid #d00000;
            border-radius: 50%;
            margin: 0 auto 1.5rem;
            animation: spin 1s linear infinite;
        }

        .loading-text {
            color: #ffffff;
            font-size: 1.25rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            letter-spacing: 0.5px;
            text-transform: uppercase;
        }

        .loading-subtext {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes scaleIn {
            from {
                transform: scale(0.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        @media (max-width: 768px) {
            .chat-container {
                height: calc(100dvh - 70px);
                /* Use dvh for better mobile support */
            }

            /* Hide footer on mobile to prevent clutter and scrolling issues */
            #footer-placeholder {
                display: none !important;
            }

            .chat-history {
                padding: 1rem !important;
                padding-bottom: 14rem !important;
                /* Extra padding for controls + input area on mobile */
            }

            .message {
                max-width: 85% !important;
                padding: 0.875rem 1rem !important;
                font-size: 0.9rem !important;
                margin-bottom: 1rem !important;
            }

            .chat-input-area {
                padding: 0.75rem !important;
                position: fixed;
                /* Fixed position to prevent jumping */
                bottom: 0;
                left: 0;
                right: 0;
                background-color: #0a0a0a;
                border-top: 2px solid #333;
                box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.8);
            }

            .chat-input-area .form-control {
                padding: 0.75rem !important;
                font-size: 16px;
                /* Prevent zoom on iOS */
            }

            .chat-input-area .btn {
                padding: 0.75rem 1rem !important;
                font-size: 0.875rem;
            }

            /* Custom styling for select dropdown on mobile */
            #coachPersona {
                -webkit-appearance: none;
                -moz-appearance: none;
                appearance: none;
                background-color: #1a1a1a !important;
                color: #ffffff !important;
                border: 1px solid #6c757d !important;
                padding: 0.6rem 2rem 0.6rem 0.75rem !important;
                font-size: 0.75rem !important;
                background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23ffffff' d='M6 9L1 4h10z'/%3E%3C/svg%3E") !important;
                background-repeat: no-repeat !important;
                background-position: right 0.5rem center !important;
                background-size: 12px !important;
            }

            /* Style the dropdown options on mobile */
            #coachPersona option {
                background-color: #1a1a1a;
                color: #ffffff;
                padding: 1rem;
            }

            /* Gender toggle buttons on mobile */
            .btn-group label {
                font-size: 0.75rem !important;
                padding: 0.6rem 0.5rem !important;
            }

            .scroll-hint {
                bottom: 85px;
                font-size: 0.75rem;
                padding: 0.4rem 0.8rem;
            }
        }
    </style>
</head>

<body class="bg-black text-light">

    <!-- Header Component -->
    <div id="header-placeholder"></div>

    <!-- Chat Interface -->
    <div class="container-fluid p-0 chat-container">
        <div class="chat-history" id="chatHistory">
            <div class="message ai">
                <strong>Coach:</strong> Welcome. I am your Relationship Strategist. I don't offer comforting lies, only
                effective tactics. What is your current situation?
            </div>
        </div>
        <div class="scroll-hint" id="scrollHint">Scroll down to type your message</div>
        <div class="typing-indicator px-4" id="typingIndicator">Coach is analyzing...</div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" id="loadingOverlay" style="display: none;">
            <div class="loading-card">
                <div class="loading-spinner"></div>
                <div class="loading-text">Coach is analyzing...</div>
                <div class="loading-subtext">Processing your situation</div>
            </div>
        </div>

        <style>
            /* Premium Minimize/Maximize Controls - Mobile Only */
            #chatControls {
                transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
                max-height: 200px;
                opacity: 1;
                overflow: hidden;
                position: relative;
            }

            /* Subtle toggle indicator - Mobile only */
            .controls-toggle-indicator {
                position: absolute;
                top: 6px;
                left: 50%;
                transform: translateX(-50%);
                width: 36px;
                height: 4px;
                background: rgba(255, 255, 255, 0.2);
                border-radius: 2px;
                transition: all 0.3s;
                cursor: pointer;
                z-index: 10;
                display: none;
                /* Hidden by default */
            }

            /* Show indicator only on mobile */
            @media (max-width: 768px) {
                #chatControls {
                    padding-top: 16px;
                    /* Space for indicator on mobile */
                }

                .controls-toggle-indicator {
                    display: block;
                }

                .controls-toggle-indicator:active {
                    background: rgba(255, 255, 255, 0.4);
                }

                .chat-input-area.minimized #chatControls {
                    max-height: 0;
                    opacity: 0;
                    margin-bottom: 0 !important;
                    padding-top: 0;
                }

                .chat-input-area.minimized .controls-toggle-indicator {
                    top: -8px;
                    background: rgba(255, 255, 255, 0.3);
                }
            }

            .chat-input-area {
                transition: transform 0.3s ease;
            }
        </style>

        <div class="chat-input-area">
            <!-- Gender Toggle - Inside fixed input area -->
            <!-- Settings Row -->
            <!-- Controls Row -->
            <div class="row g-2 mb-3" id="chatControls">
                <!-- Toggle Indicator -->
                <div class="controls-toggle-indicator" id="controlsToggle" title="Click to hide/show controls"></div>
                <!-- Gender Toggle -->
                <div class="col-12 col-md-6" id="genderToggleContainer">
                    <div class="btn-group w-100" role="group">
                        <input type="radio" class="btn-check" name="genderPreference" id="genderMale" value="male"
                            checked>
                        <label class="btn btn-outline-primary rounded-0 py-2 text-uppercase fw-bold ls-1"
                            for="genderMale" style="font-size: 0.8rem;">
                            For Men
                        </label>

                        <input type="radio" class="btn-check" name="genderPreference" id="genderFemale" value="female">
                        <label class="btn btn-outline-danger rounded-0 py-2 text-uppercase fw-bold ls-1"
                            for="genderFemale" style="font-size: 0.8rem;">
                            For Women
                        </label>
                    </div>
                </div>

                <!-- Persona Select -->
                <div class="col-12 col-md-6">
                    <select
                        class="form-select bg-dark text-white border-secondary rounded-0 text-uppercase text-center py-2"
                        id="coachPersona" style="font-size: 0.8rem; letter-spacing: 0.5px; height: 100%;">
                        <option value="standard">Standard Coach</option>
                        <option value="drill_sergeant">Drill Sergeant</option>
                        <option value="wingman">The Wingman</option>
                        <option value="therapist">Relationship Therapist</option>
                    </select>
                </div>
            </div>

            <!-- Input Form -->
            <form id="chatForm" class="d-flex gap-2 align-items-center">
                <input type="text" id="userInput"
                    class="form-control form-control-lg bg-dark text-white border-secondary rounded-0"
                    placeholder="Describe your situation..." required autocomplete="off" style="font-size: 1rem;">

                <button type="button" id="voiceBtn"
                    class="btn btn-outline-light btn-lg rounded-0 px-3 d-flex align-items-center justify-content-center"
                    style="display: none; height: 48px; width: 48px;" title="Hold to Speak">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                        class="bi bi-mic-fill" viewBox="0 0 16 16">
                        <path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z" />
                        <path
                            d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z" />
                    </svg>
                </button>

                <button type="submit" class="btn btn-danger btn-lg rounded-0 px-3 fw-bold d-flex align-items-center"
                    style="height: 48px;">
                    <span class="d-none d-md-inline">SEND</span>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor"
                        class="bi bi-send-fill d-md-none" viewBox="0 0 16 16">
                        <path
                            d="M15.854.146a.5.5 0 0 1 .11.54l-5.819 14.547a.75.75 0 0 1-1.329.124l-3.178-4.995L.643 7.184a.75.75 0 0 1 .124-1.33L15.314.037a.5.5 0 0 1 .54.11ZM6.636 10.07l2.761 4.338L14.13 2.576 6.636 10.07Zm6.787-8.201L1.591 6.602l4.339 2.76 7.494-7.493Z" />
                    </svg>
                </button>

                <!-- Options Dropdown -->
                <div class="dropdown">
                    <button
                        class="btn btn-outline-secondary btn-lg rounded-0 d-flex align-items-center justify-content-center"
                        type="button" data-bs-toggle="dropdown" aria-expanded="false"
                        style="height: 48px; width: 48px;">
                        &#8942;
                    </button>
                    <ul class="dropdown-menu dropdown-menu-end dropdown-menu-dark shadow-lg border-secondary"
                        style="min-width: 200px;">
                        <li>
                            <h6 class="dropdown-header text-uppercase small text-white-50" style="letter-spacing: 1px;">
                                Output Language</h6>
                        </li>
                        <li><a class="dropdown-item language-option active" href="#" data-lang="English">ðŸ‡ºðŸ‡¸
                                English</a></li>
                        <li><a class="dropdown-item language-option" href="#" data-lang="Hinglish">ðŸ‡®ðŸ‡³ Hinglish</a>
                        </li>
                        <li><a class="dropdown-item language-option" href="#" data-lang="Hindi">ðŸ‡®ðŸ‡³ Hindi</a></li>
                        <li><a class="dropdown-item language-option" href="#" data-lang="Spanish">ðŸ‡ªðŸ‡¸ Spanish</a></li>
                        <li><a class="dropdown-item language-option" href="#" data-lang="French">ðŸ‡«ðŸ‡· French</a></li>
                        <li><a class="dropdown-item language-option" href="#" data-lang="Italian">ðŸ‡®ðŸ‡¹ Italian</a></li>
                        <li>
                            <div class="dropdown-divider border-secondary"></div>
                        </li>
                        <li><a class="dropdown-item text-danger" href="#" id="clearHistoryOption">Clear Chat History</a>
                        </li>
                    </ul>
                </div>
            </form>
        </div>
    </div>

    <!-- Footer Component - Removed for cleaner UI
    <div id="footer-placeholder"></div> -->

    <script src="js/components.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz"
        crossorigin="anonymous"></script>
    <script src="js/navbar.js"></script>
    <script src="js/toast.js"></script>
    <script src="js/config.js"></script>
    <script>
        const chatForm = document.getElementById('chatForm');
        const userInput = document.getElementById('userInput');
        const chatHistory = document.getElementById('chatHistory');
        const typingIndicator = document.getElementById('typingIndicator');
        const scrollHint = document.getElementById('scrollHint');

        // Handle scroll hint visibility
        function checkScrollHint() {
            const isNearBottom = chatHistory.scrollHeight - chatHistory.scrollTop - chatHistory.clientHeight < 150;
            if (isNearBottom || userInput.value.length > 0) {
                scrollHint.classList.add('hidden');
            } else {
                scrollHint.classList.remove('hidden');
            }
        }

        // Check on scroll
        chatHistory.addEventListener('scroll', checkScrollHint);

        // Check on input
        userInput.addEventListener('input', checkScrollHint);

        // Check on focus
        userInput.addEventListener('focus', () => {
            scrollHint.classList.add('hidden');
        });

        // Initial check
        setTimeout(checkScrollHint, 500);

        // Load chat history
        async function loadChatHistory(gender = null) {
            const token = localStorage.getItem('access_token');

            // Determine gender to load (default to current selection if not provided)
            if (!gender) {
                if (token) {
                    // For logged-in, we'll fetch user preference first or just default to male
                    // But usually we want to load based on what's selected in UI
                    gender = document.querySelector('input[name="genderPreference"]:checked')?.value || 'male';
                } else {
                    gender = localStorage.getItem('guest_gender_preference') || 'male';
                }
            }

            if (!token) {
                // Guest user - load from localStorage based on gender
                const storageKey = `guest_chat_history_${gender}`;
                const guestHistory = localStorage.getItem(storageKey);

                chatHistory.innerHTML = ''; // Clear current view

                if (guestHistory) {
                    try {
                        const messages = JSON.parse(guestHistory);
                        if (messages.length > 0) {
                            messages.forEach(msg => {
                                appendMessage(msg.sender, msg.content, false); // false = don't save again
                            });
                        } else {
                            showWelcomeMessage(gender);
                        }
                    } catch (error) {
                        console.error('Error loading guest history:', error);
                        showWelcomeMessage(gender);
                    }
                } else {
                    showWelcomeMessage(gender);
                }

                // Scroll to bottom
                setTimeout(() => {
                    chatHistory.scrollTop = chatHistory.scrollHeight;
                }, 100);
                return;
            }

            // Logged-in user - load from server with coach_type filter
            try {
                const response = await fetch(`${API_BASE_URL}/chat/history?coach_type=${gender}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    const data = await response.json();
                    chatHistory.innerHTML = ''; // Clear current view

                    if (data.messages.length > 0) {
                        data.messages.forEach(msg => {
                            // Map role 'assistant' to 'ai' for CSS class
                            const sender = msg.role === 'assistant' ? 'ai' : 'user';
                            appendMessage(sender, msg.content, false); // false = don't save again
                        });
                    } else {
                        showWelcomeMessage(gender);
                    }

                    // Scroll to bottom
                    setTimeout(() => {
                        chatHistory.scrollTop = chatHistory.scrollHeight;
                    }, 100);
                }
            } catch (error) {
                console.error('Error loading history:', error);
            }
        }

        function showWelcomeMessage(gender) {
            const message = gender === 'male'
                ? "Welcome. I am your Relationship Strategist. I don't offer comforting lies, only effective tactics. What is your current situation?"
                : "Welcome. I am your Relationship Guide. I'm here to help you decode his behavior and find clarity. What's on your mind?";

            chatHistory.innerHTML = `
                <div class="message ai">
                    <strong>Coach:</strong> ${message}
                </div>
            `;
        }

        loadChatHistory();

        // Auto-scroll to bottom on page load to show toggle and input box
        setTimeout(() => {
            chatHistory.scrollTop = chatHistory.scrollHeight;
        }, 100);

        // Check for token and guest query count
        const token = localStorage.getItem('access_token');
        const isGuest = !token;
        let guestQueryCount = parseInt(localStorage.getItem('guest_query_count') || '0');
        const GUEST_QUERY_LIMIT = 5;

        // Gender preference toggle
        const genderToggleContainer = document.getElementById('genderToggleContainer');
        const genderMaleRadio = document.getElementById('genderMale');
        const genderFemaleRadio = document.getElementById('genderFemale');

        genderToggleContainer.style.display = 'block';

        if (!isGuest) {
            // Logged-in user - load from server and save to server
            async function loadGenderPreference() {
                try {
                    const response = await fetch(`${API_BASE_URL}/users/me`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    if (response.ok) {
                        const userData = await response.json();
                        if (userData.gender_preference === 'female') {
                            genderFemaleRadio.checked = true;
                        } else {
                            genderMaleRadio.checked = true;
                        }
                    }
                } catch (error) {
                    console.error('Error loading gender preference:', error);
                }
            }

            loadGenderPreference();

            // Handle gender preference change
            async function updateGenderPreference(gender) {
                try {
                    const response = await fetch(`${API_BASE_URL}/update-profile`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({ gender_preference: gender })
                    });

                    if (response.ok) {
                        console.log(`Gender preference updated to: ${gender}`);
                        // Reload chat history for the new coach type
                        loadChatHistory(gender);
                    }
                } catch (error) {
                    console.error('Error updating gender preference:', error);
                }
            }

            genderMaleRadio.addEventListener('change', () => {
                if (genderMaleRadio.checked) {
                    updateGenderPreference('male');
                }
            });

            genderFemaleRadio.addEventListener('change', () => {
                if (genderFemaleRadio.checked) {
                    updateGenderPreference('female');
                }
            });
        } else {
            // Guest user - load from localStorage and save to localStorage
            const savedGenderPreference = localStorage.getItem('guest_gender_preference') || 'male';
            if (savedGenderPreference === 'female') {
                genderFemaleRadio.checked = true;
            } else {
                genderMaleRadio.checked = true;
            }

            function updateGuestGenderPreference(gender) {
                localStorage.setItem('guest_gender_preference', gender);
                console.log(`Guest gender preference updated to: ${gender}`);
                // Reload chat history for the new coach type
                loadChatHistory(gender);
            }

            genderMaleRadio.addEventListener('change', () => {
                if (genderMaleRadio.checked) {
                    updateGuestGenderPreference('male');
                }
            });

            genderFemaleRadio.addEventListener('change', () => {
                if (genderFemaleRadio.checked) {
                    updateGuestGenderPreference('female');
                }
            });

            // Persona Visual Feedback
            const coachPersona = document.getElementById('coachPersona');
            function updatePersonaStyle() {
                const persona = coachPersona.value;
                // Reset basic border
                coachPersona.style.borderColor = '';
                coachPersona.style.boxShadow = '';

                if (persona === 'drill_sergeant') {
                    coachPersona.style.borderColor = '#dc3545'; // danger
                    coachPersona.style.boxShadow = '0 0 5px rgba(220, 53, 69, 0.5)';
                } else if (persona === 'wingman') {
                    coachPersona.style.borderColor = '#0dcaf0'; // info
                    coachPersona.style.boxShadow = '0 0 5px rgba(13, 202, 240, 0.5)';
                } else if (persona === 'therapist') {
                    coachPersona.style.borderColor = '#198754'; // success
                    coachPersona.style.boxShadow = '0 0 5px rgba(25, 135, 84, 0.5)';
                } else {
                    coachPersona.style.borderColor = '#6c757d'; // secondary
                }
            }
            coachPersona.addEventListener('change', updatePersonaStyle);
        }

        // Clear history button logic
        const clearHistoryOption = document.getElementById('clearHistoryOption');

        if (clearHistoryOption) {
            clearHistoryOption.addEventListener('click', async (e) => {
                e.preventDefault();

                if (!confirm('Are you sure you want to clear your chat history? This cannot be undone.')) {
                    return;
                }

                const gender = document.querySelector('input[name="genderPreference"]:checked')?.value || 'male';

                if (isGuest) {
                    // Clear guest history
                    const storageKey = `guest_chat_history_${gender}`;
                    localStorage.removeItem(storageKey);
                    chatHistory.innerHTML = '';
                    showWelcomeMessage(gender);
                    if (typeof showToast === 'function') showToast('Chat history cleared.', 'success');
                } else {
                    // Clear logged-in user history
                    try {
                        const response = await fetch(`${API_BASE_URL}/chat/history?coach_type=${gender}`, {
                            method: 'DELETE',
                            headers: {
                                'Authorization': `Bearer ${token}`
                            }
                        });

                        if (response.ok) {
                            chatHistory.innerHTML = '';
                            showWelcomeMessage(gender);
                            if (typeof showToast === 'function') showToast('Chat history cleared.', 'success');
                        } else {
                            if (typeof showToast === 'function') showToast('Failed to clear history.', 'error');
                        }
                    } catch (error) {
                        console.error('Error clearing history:', error);
                        if (typeof showToast === 'function') showToast('Error clearing history.', 'error');
                    }
                }
            });
        }

        // Language Selection Logic
        let currentLanguage = localStorage.getItem('chat_language_preference') || 'English';

        // Update UI to match stored preference
        document.querySelectorAll('.language-option').forEach(item => {
            if (item.getAttribute('data-lang') === currentLanguage) {
                item.classList.add('active');
            } else {
                item.classList.remove('active');
            }

            item.addEventListener('click', (e) => {
                e.preventDefault();
                // Remove active from all
                document.querySelectorAll('.language-option').forEach(el => el.classList.remove('active'));
                // Add to click
                e.currentTarget.classList.add('active');

                // Update variable and storage
                currentLanguage = e.currentTarget.getAttribute('data-lang');
                localStorage.setItem('chat_language_preference', currentLanguage);

                if (typeof showToast === 'function') showToast(`Output language set to ${currentLanguage}`, 'info');
            });
        });

        // Show guest status in initial message if applicable
        if (isGuest) {
            const queriesLeft = GUEST_QUERY_LIMIT - guestQueryCount;
            if (queriesLeft > 0) {
                appendMessage('ai', `You have ${queriesLeft} free queries remaining. Sign up to get more!`);
            }
        }

        chatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const message = userInput.value.trim();
            if (!message) return;

            // Check guest query limit
            if (isGuest) {
                if (guestQueryCount >= GUEST_QUERY_LIMIT) {
                    showToast('You\'ve used all 5 free queries! Please sign up or log in to continue.', 'warning');
                    setTimeout(() => window.location.href = 'signup.html', 2000);
                    return;
                }
            }

            // Add user message
            appendMessage('user', message);
            userInput.value = '';

            // Show loading overlay
            const loadingOverlay = document.getElementById('loadingOverlay');
            loadingOverlay.style.display = 'flex';

            try {
                let endpoint, headers, body;

                if (isGuest) {
                    // Guest endpoint - include gender preference and conversation history
                    const guestGenderPreference = localStorage.getItem('guest_gender_preference') || 'male';
                    const storageKey = `guest_chat_history_${guestGenderPreference}`;
                    const guestHistory = localStorage.getItem(storageKey);

                    // Build history array (limit to last 20 messages for performance)
                    let history = [];
                    if (guestHistory) {
                        try {
                            const messages = JSON.parse(guestHistory);
                            // Take last 20 messages and format for API
                            history = messages.slice(-20).map(msg => ({
                                role: msg.sender === 'user' ? 'user' : 'assistant',
                                content: msg.content
                            }));
                        } catch (error) {
                            console.error('Error parsing guest history:', error);
                        }
                    }

                    // Get selected persona
                    const persona = document.getElementById('coachPersona').value;

                    endpoint = `${API_BASE_URL}/guest-chat`;
                    headers = { 'Content-Type': 'application/json' };
                    body = JSON.stringify({
                        message: message,
                        gender_preference: guestGenderPreference,
                        history: history,
                        persona: persona
                    });
                } else {
                    // Authenticated endpoint
                    const persona = document.getElementById('coachPersona').value;

                    endpoint = `${API_BASE_URL}/chat`;
                    headers = {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    };
                    body = JSON.stringify({
                        message: message,
                        persona: persona,
                        language: currentLanguage
                    });
                }

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: headers,
                    body: body,
                    keepalive: true  // Ensures request continues even if tab is switched
                });

                if (response.status === 401) {
                    showToast('Session expired. Please login again.', 'error');
                    localStorage.removeItem('access_token');
                    setTimeout(() => window.location.href = 'login.html', 2000);
                    return;
                }

                if (response.status === 403) {
                    const error = await response.json();
                    showToast(error.detail, 'warning');
                    setTimeout(() => window.location.href = 'profile.html', 2000);
                    return;
                }

                const data = await response.json();

                // Increment guest query count
                if (isGuest) {
                    guestQueryCount++;
                    localStorage.setItem('guest_query_count', guestQueryCount.toString());

                    const queriesLeft = GUEST_QUERY_LIMIT - guestQueryCount;
                    if (queriesLeft > 0) {
                        appendMessage('ai', data.response + `\n\n(${queriesLeft} free queries remaining)`);
                    } else {
                        appendMessage('ai', data.response + '\n\nThat was your last free query! Sign up to continue.');
                    }
                } else {
                    appendMessage('ai', data.response);
                }

                // Hide loading overlay
                loadingOverlay.style.display = 'none';

            } catch (error) {
                console.error('Error:', error);
                loadingOverlay.style.display = 'none';
                appendMessage('ai', 'Connection lost. The matrix is interfering. Try again.');
            }
        });

        // Format text with paragraph breaks and bullet points
        function formatText(text) {
            // Escape HTML to prevent XSS
            const escapeHtml = (unsafe) => {
                return unsafe
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            };

            let formatted = escapeHtml(text);

            // Helper to parse inline markdown
            const parseInline = (str) => {
                return str
                    .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                    .replace(/\*(.*?)\*/g, '<em>$1</em>');
            };

            // Split into lines
            let lines = formatted.split('\n');
            let html = '';
            let inBulletList = false;

            for (let i = 0; i < lines.length; i++) {
                let line = lines[i].trim();

                if (line === '') {
                    // Empty line = paragraph break
                    if (inBulletList) {
                        html += '</ul>';
                        inBulletList = false;
                    }
                    html += '<br>';
                } else {
                    // Check for bullet points
                    // We check for '* ' (asterisk space) to distinguish from italics
                    let isBullet = line.startsWith('-') || line.startsWith('â€¢') || line.startsWith('* ');

                    if (isBullet) {
                        // Bullet point
                        if (!inBulletList) {
                            html += '<ul style="margin: 8px 0; padding-left: 20px;">';
                            inBulletList = true;
                        }
                        let content = line.substring(1).trim();
                        content = parseInline(content);
                        html += '<li style="margin: 4px 0;">' + content + '</li>';
                    } else {
                        // Regular text
                        if (inBulletList) {
                            html += '</ul>';
                            inBulletList = false;
                        }
                        let content = parseInline(line);
                        html += content + '<br>';
                    }
                }
            }

            // Close any open bullet list
            if (inBulletList) {
                html += '</ul>';
            }

            return html;
        }

        function appendMessage(sender, text, save = true) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender);

            // Add strong tag for sender name
            const senderName = sender === 'user' ? 'You' : 'Coach';

            // Format AI responses with proper HTML
            const formattedText = sender === 'ai' ? formatText(text) : text.replace(/\n/g, '<br>');

            messageDiv.innerHTML = `<strong>${senderName}:</strong> ${formattedText}`;

            chatHistory.appendChild(messageDiv);
            chatHistory.scrollTop = chatHistory.scrollHeight;

            // Only save to localStorage for guest users if save is true
            // IMPORTANT: Check isGuest variable, not just token presence
            if (isGuest && save) {
                saveGuestMessage(sender, text);
            }
            // For logged-in users, messages are saved server-side via API
        }

        // Save guest message to localStorage with proper gender separation
        function saveGuestMessage(sender, content) {
            try {
                // Get the CURRENT gender preference for proper storage key
                const gender = localStorage.getItem('guest_gender_preference') || 'male';
                const storageKey = `guest_chat_history_${gender}`;

                const guestHistory = localStorage.getItem(storageKey);
                let messages = guestHistory ? JSON.parse(guestHistory) : [];

                messages.push({ sender, content });

                // Keep only last 50 messages to avoid localStorage size limits
                if (messages.length > 50) {
                    messages = messages.slice(-50);
                }

                localStorage.setItem(storageKey, JSON.stringify(messages));
                console.log(`Saved message to ${storageKey}:`, { sender, content });
            } catch (error) {
                console.error('Error saving guest message:', error);
            }
        }
        // --- Voice Recording Logic ---
        const voiceBtn = document.getElementById('voiceBtn');
        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;

        // Show button if not guest
        if (!isGuest) {
            voiceBtn.style.display = 'block';
        }

        voiceBtn.addEventListener('click', async () => {
            if (!isRecording) {
                // Start Recording
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                    // Detect supported mime type
                    let mimeType = 'audio/webm';
                    if (MediaRecorder.isTypeSupported('audio/mp4')) mimeType = 'audio/mp4';
                    else if (MediaRecorder.isTypeSupported('audio/mpeg')) mimeType = 'audio/mpeg'; // Unlikely for recorder

                    mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
                    audioChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        // Create Blob
                        const audioBlob = new Blob(audioChunks, { type: mimeType });

                        // Change UI to loading
                        userInput.placeholder = "Transcribing audio...";
                        userInput.disabled = true;
                        voiceBtn.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>';

                        // Create FormData
                        const formData = new FormData();
                        formData.append('file', audioBlob, 'recording' + (mimeType === 'audio/mp4' ? '.m4a' : '.webm'));

                        try {
                            // Get fresh token
                            const currentToken = localStorage.getItem('access_token');
                            if (!currentToken) {
                                throw new Error('Please log in to use voice recording');
                            }

                            const response = await fetch(`${API_BASE_URL}/transcribe`, {
                                method: 'POST',
                                headers: {
                                    'Authorization': `Bearer ${currentToken}`
                                },
                                body: formData
                            });

                            if (!response.ok) {
                                const errorData = await response.json().catch(() => ({}));
                                const errorMsg = errorData.detail || `Transcription failed (${response.status})`;
                                throw new Error(errorMsg);
                            }

                            const data = await response.json();
                            userInput.value = data.text;
                            userInput.focus();

                        } catch (error) {
                            console.error('Transcription error:', error);
                            const errorMessage = error.message || 'Failed to transcribe audio. Please try again.';
                            showToast(errorMessage, 'error');
                        } finally {
                            // Reset UI
                            userInput.placeholder = "Describe your situation...";
                            userInput.disabled = false;
                            voiceBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-mic-fill" viewBox="0 0 16 16"><path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z"/><path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/></svg>';
                            voiceBtn.classList.remove('btn-danger');
                            voiceBtn.classList.add('btn-outline-light');
                        }

                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };

                    mediaRecorder.start();
                    isRecording = true;

                    // UI Updates for Recording
                    voiceBtn.classList.remove('btn-outline-light');
                    voiceBtn.classList.add('btn-danger', 'pulse-animation'); // Add pulse class if you have it
                    showToast("Recording... Click mic to stop.", "info");

                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    showToast("Could not access microphone. Please check permissions.", "error");
                }
            } else {
                // Stop Recording
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                    isRecording = false;
                }
            }
        });

        // --- Minimize/Maximize Controls (Mobile Only) ---
        const chatInputArea = document.querySelector('.chat-input-area');
        const chatControls = document.getElementById('chatControls');
        const chatHistoryContainer = document.querySelector('.chat-history');
        const controlsToggle = document.getElementById('controlsToggle');

        // Only enable on mobile
        if (chatInputArea && chatControls && controlsToggle && window.innerWidth <= 768) {
            let startY = 0;
            let currentY = 0;
            let isDragging = false;
            let isMinimized = false;

            // Touch Swipe Logic on the controls area itself
            chatControls.addEventListener('touchstart', (e) => {
                startY = e.touches[0].clientY;
                isDragging = true;
            }, { passive: true });

            chatControls.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                currentY = e.touches[0].clientY;
            }, { passive: true });

            chatControls.addEventListener('touchend', (e) => {
                if (!isDragging) return;
                isDragging = false;

                const deltaY = currentY - startY;
                const threshold = 30; // Lower threshold for easier swipe

                if (!isMinimized && deltaY > threshold) {
                    // Swiped Down -> Minimize
                    toggleMinimize(true);
                } else if (isMinimized && deltaY < -threshold) {
                    // Swiped Up -> Expand  
                    toggleMinimize(false);
                }

                // Reset
                startY = 0;
                currentY = 0;
            });

            function toggleMinimize(forceState = null) {
                if (forceState !== null) {
                    isMinimized = forceState;
                } else {
                    isMinimized = !isMinimized;
                }

                if (isMinimized) {
                    chatInputArea.classList.add('minimized');
                    if (window.innerWidth <= 768) {
                        chatHistoryContainer.style.paddingBottom = '6rem';
                    }
                } else {
                    chatInputArea.classList.remove('minimized');
                    if (window.innerWidth <= 768) {
                        chatHistoryContainer.style.paddingBottom = '14rem';
                    }
                }
            }
        }
    </script>
</body>

</html>